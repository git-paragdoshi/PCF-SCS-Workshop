= Lab 3 - Monitoring, Metrics and HA Lab

[abstract]
--
Pivotal Cloud Foundry makes the work of performing actions, such as managing logs, doing a zero-downtime deploy, and managing application health very easy.
In the this labs we'll explore some of these capabilities.
--

== Tailing Application Logs

One of the most important enablers of visibility into application behavior is logging.
Effective management of logs has historically been difficult or required wiring into third party tools.
Cloud Foundry's https://docs.pivotal.io/pivotalcf/1-9/loggregator/architecture.html[log aggregation] components simplify log management by assuming responsibility for it.
Application developers need only log all messages to either 'System.out' in Java or  `STDOUT` or `STDERR` in other languages, and the platform will capture these messages.

=== For Developers

Application developers can view application logs using the CF CLI.

. Let's view recent log messages for the application.
+
----
> cf logs paragdoshi-articulate --recent
----
+
Here are some interesting subsets of one output from that command:
+
.CF Component Logs
====
----
> cf logs paragdoshi-articulate --recent
Connected, dumping recent logs for app paragdoshi-articulate in org PapaJohns / space workshop as pdoshi@pivotal.io...

2017-04-03T13:04:50.21-0400 [APP/PROC/WEB/0]OUT 2017-04-03 17:04:50.212  INFO 14 --- [           main] s.b.c.e.t.TomcatEmbeddedServletContainer : Tomcat started on port(s): 8080 (http)
2017-04-03T13:04:50.21-0400 [APP/PROC/WEB/0]OUT 2017-04-03 17:04:50.215  INFO 14 --- [           main] i.p.e.articulate.ArticulateApplication   : Started ArticulateApplication in 11.981 seconds (JVM running for 13.001)
2017-04-03T13:04:52.25-0400 [CELL/0]     OUT Container became healthy
2017-04-03T13:13:03.62-0400 [APP/PROC/WEB/0]OUT 2017-04-03 17:13:03.628  INFO 14 --- [nio-8080-exec-8] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring FrameworkServlet 'dispatcherServlet'
2017-04-03T13:13:03.62-0400 [APP/PROC/WEB/0]OUT 2017-04-03 17:13:03.628  INFO 14 --- [nio-8080-exec-8] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization started
2017-04-03T13:13:03.66-0400 [APP/PROC/WEB/0]OUT 2017-04-03 17:13:03.668  INFO 14 --- [nio-8080-exec-8] o.s.web.servlet.DispatcherServlet        : FrameworkServlet 'dispatcherServlet': initialization completed in 40 ms
2017-04-03T13:13:04.35-0400 [RTR/5]      OUT paragdoshi-articulate.cfapps.io - [2017-04-03T17:13:03.595+0000] "GET / HTTP/1.1" 200 0 7830 "-" "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36" "10.10.2.141:21261" "10.10.148.95:61096" x_forwarded_for:"208.102.173.112" x_forwarded_proto:"https" vcap_request_id:"ebd83dd8-9883-4645-4e1f-dff10e1109c0" response_time:0.759711021 app_id:"8e5b3fd9-272b-41bc-8a5e-b08528e06da0" app_index:"0" x_b3_traceid:"4caa316b231ffbe0" x_b3_spanid:"4caa316b231ffbe0" x_b3_parentspanid:"-"


----
<1> An ``Apache-style'' access log event from the (Go)Router
<2> An API log event that corresponds to an event as shown in `cf events`
<3> A CELL log event indicating the start of an application instance on that CELL.
====

As you can see, Cloud Foundry's log aggregation components capture both application logs and CF component logs relevant to your application.
These events are properly interleaved based on time, giving you an accurate picture of events as they transpired across the system.  In this case we output Kaboom when the kill button is pressed in the .NET app

. To get a running ``tail'' of the application logs rather than a dump, simply type:
+
----
> cf logs paragdoshi-articulate
----
+
You can try various things like refreshing the browser and triggering stop/start events to see logs being generated.

== Health Management

Cloud Foundry's https://docs.pivotal.io/pivotalcf/1-9/concepts/architecture/#nsync-bbs[components] actively monitors the health of our application processes and will restart them should they crash.

. If you don't have one already running, start a log tail for your articulate application. 
+
----
> cf logs paragdoshi-articulate
----

. If you do not have more than one application instance running, execute the scale command to scale to 2 or more application instances.  Visit the application in the browser, and click on the ``Kill Switch'' button. This button will trigger an Environment.Exit(-1) causing the Health Manager to observe an application instance crash:
+
image::../../Common/images/lab-kill-button.png[]

. After clicking the kill switch a couple of interesting things should happen.
First, you'll see an error code returned in the browser, as the request you submitted never returns a response:
+
image::../../Common/images/lab-kill-failed.png[]
+
Also, if you're paying attention to the log tail, you'll see some interesting log messages fly by:
+
====
----
2017-01-25T17:02:43.40-0500 [APP/0]      OUT Kaboom.
2017-01-25T17:02:43.44-0500 [APP/0]      OUT Exit status -1
2017-01-25T17:02:43.59-0500 [CELL/0]     OUT Exit status -26
2017-01-25T17:02:43.59-0500 [CELL/0]     OUT Destroying container
----
<1> Just before issuing the `Environment.Exit(-1)` call, the application logs that the kill switch was clicked.
<2> The (Go)Router logs the 502 error.
<3> The API logs that an application instance exited due to a crash.
====

. Wait a few seconds...  By this time you should have noticed some additional interesting events in the logs:
+
====
----
2017-01-25T17:02:43.62-0500 [CELL/0]     OUT Creating container
2017-01-25T17:02:43.95-0500 [CELL/0]     OUT Successfully destroyed container
2017-01-25T17:02:45.23-0500 [CELL/0]     OUT Successfully created container
2017-01-25T17:02:46.30-0500 [CELL/0]     OUT Starting health monitoring of container
2017-01-25T17:02:53.31-0500 [APP/0]      OUT PORT == 61457
2017-01-25T17:02:53.31-0500 [APP/0]      OUT Running ..\tmp\lifecycle\WebAppServer.exe
2017-01-25T17:02:53.31-0500 [APP/0]      OUT 2017-01-25 22:02:49Z|INFO|Port:61457
2017-01-25T17:02:53.31-0500 [APP/0]      OUT 2017-01-25 22:02:49Z|INFO|Webroot:C:\containerizer\03670EBEB3A9F2BFB5\user\app
2017-01-25T17:02:53.31-0500 [APP/0]      OUT 2017-01-25 22:02:49Z|INFO|Starting web server instance...
2017-01-25T17:02:53.31-0500 [APP/0]      OUT Server Started.... press CTRL + C to stop
2017-01-25T17:02:53.31-0500 [APP/0]      OUT Checking DB structure.
2017-01-25T17:02:53.86-0500 [CELL/0]     OUT Container became healthy
----
<1> The CELL indicates that it is starting another instance of the application as a result of the Health Manager observing a difference between the desired and actual state (i.e. running instances = 1 vs. running instances = 0).
<2> The new application instance starts logging events as it starts up.
====

. Revisiting the *HOME PAGE* of the application and you should see a fresh instance started:
+
image::../../Common/images/lab-kill-ok.png[]

== Viewing Application _Events_

Cloud Foundry only allows application configuration to be modified via its API.
This gives application operators confidence that all changes to application configuration are known and auditable.
It also reduces the number of causes that must be considered when problems arise.

All application configuration changes are recorded as _events_.
These events can be viewed via the Cloud Foundry API, and viewing is facilitated via the CLI.

Take a look at the events that have transpired so far for our deployment of `workshop`:

====
----
> cf events env
Getting events for app env in org student-42 / space development as student-42...

time                          event                   actor        description
2017-01-25T17:04:11.00-0500   app.crash               env          index: 0, reason: CRASHED, exit_description: 2 error(s) occurred:

                                                                   * 2 error(s) occurred:

                                                                   * Exited with status -1
                                                                   * cancelled
                                                                   * cancelled
2017-01-25T16:53:44.00-0500   audit.app.update        student-42
2017-01-25T16:53:44.00-0500   audit.app.unmap-route   student-42
2017-01-25T16:50:30.00-0500   audit.app.update        student-42
2017-01-25T16:50:30.00-0500   audit.app.map-route     student-42
2017-01-25T15:50:28.00-0500   audit.app.update        student-42
2017-01-25T15:50:28.00-0500   audit.app.unmap-route   student-42
2017-01-25T15:43:23.00-0500   audit.app.update        student-42
2017-01-25T15:43:23.00-0500   audit.app.map-route     student-42
2017-01-25T15:22:16.00-0500   audit.app.update        student-42   instances: 1
2017-01-25T15:13:51.00-0500   audit.app.update        student-42   instances: 3
2017-01-25T08:58:06.00-0500   audit.app.restage       student-42
2017-01-25T08:39:40.00-0500   audit.app.update        student-42   state: STARTED
2017-01-25T08:39:33.00-0500   audit.app.update        student-42
2017-01-25T08:39:33.00-0500   audit.app.map-route     student-42
2017-01-25T08:39:32.00-0500   audit.app.create        student-42   instances: 1, memory: 512, state: STOPPED, environment_json: PRIVATE DATA HIDDEN
----
<1> Events are sorted newest to oldest, so we'll start from the bottom.
Here we see the `app.create` event, which created our application's record and stored all of its metadata (e.g. `memory: 512`).
<2> The `app.map-route` event records the incoming request to assign a route to our application.
<3> An `app.update` event records the resulting change to our applications metadata.
<4> An `app.update` event records the change of our application's state to `STARTED`.
<5> Remember scaling the application up? An `app.update` event records the metadata change `instances: 2`.
<6> Also there's the `app.crash` event recording that we encountered a crash of an application instance.
====

. Let's explicitly ask for the application to be stopped:
+
----
> cf stop env
Stopping app env in org student-42 / space development as student-42...
OK

----

. Now, examine the additional `app.update` event:
+
----
> cf events env
Getting events for app env in org student-42 / space development as student-42...

time                          event                   actor        description
2017-01-25T17:10:18.00-0500   audit.app.update        student-42   state: STOPPED
2017-01-25T17:04:11.00-0500   app.crash               env          index: 0, reason: CRASHED, exit_description: 2 error(s) occurred:

                                                                   * 2 error(s) occurred:

                                                                   * Exited with status -1
                                                                   * cancelled
                                                                   * cancelled

----

. Start the application again:
+
----
> cf start env
Starting app env in org student-42 / space development as student-42...

0 of 1 instances running, 1 starting
0 of 1 instances running, 1 starting
1 of 1 instances running

App started


OK

App env was started using this command `..\tmp\lifecycle\WebAppServer.exe`

Showing health and status for app env in org student-42 / space development as student-42...
OK

requested state: started
instances: 1/1
usage: 512M x 1 instances
urls: env-patellate-catatonia.cfapps.haas-65.pez.pivotal.io
last uploaded: Wed Jan 25 13:39:36 UTC 2017
stack: windows2012R2
buildpack: binary_buildpack

     state     since                    cpu    memory          disk         details
#0   running   2017-01-25 05:12:04 PM   0.0%   84.1M of 512M   3.5M of 1G
----

. And again, view the additional `app.update` event:
+
----
> cf events env
Getting events for app env in org student-42 / space development as student-42...

time                          event                   actor        description
2017-01-25T17:11:55.00-0500   audit.app.update        student-42   state: STARTED
2017-01-25T17:10:18.00-0500   audit.app.update        student-42   state: STOPPED
----

